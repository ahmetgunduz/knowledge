:encoding: UTF-8
// The markup language of this document is AsciiDoc. 

= Compilers -- Principles, Techniques and Tools

A summary of the book with the same title.

A '(formal) language' is a set of words.  A 'word' (or 'sentence'?)  is a
sequence of 'symbols'.  The 'alphabet' of a formal language is the set of
available symbols.

A 'lexical analyzer' (aka 'lexer', 'tokenizer', 'scanner') performs 'lexical
analysis', which is the process of converting a sequence of characters into a
sequence of tokens.  A 'token' consists of a token name and an attribute
value.  The 'token name' is an abstract symbol.  It is often used as terminal
symbol in a context free grammar.  The 'attribute value' is optional
additional information about the token.

A 'context free grammar' (aka 'concrete syntax') defines a formal language.  It
consists of the following:

* A set of 'terminal (symbols)'.  In other words the alphabet of the formal
  language being defined by the grammar.  A terminal corresponds to token
  name.
* A set of 'nonterminal (symbols)' aka 'syntactic variables'.
* A set of 'production (rules)'.  A production consists of a head and a body.
  The 'head' (aka 'left side') is a nonterminal.  The 'body' (aka 'right
  side') is a sequence of grammar symbols.  The term 'Grammar symbol' is the
  generalization of terminal symbol and nonterminal symbol.
* A designation of one of the nonterminals as the 'start' symbol. 

The letter G is often used as the name of the grammar at hand.  A 'single
production' is a production whose body consists of a single nonterminal, and
nothing else.

Notational Conventions:

* terminal symbol: early lowercase letter (a, b, c, ...), digit, punctuation,
  boldface string (*if*, *else*, ...).
* nonterminal symbol: early uppercase letter (A, B, C, ...), the letter S,
  lowercase italic string ('expr', 'term', 'factor', ...).
* grammar symbol: late uppercase letter (..., X, Y, Z).
* string of terminal symbols: late lowercase italic letters ('u', 'v', ...,
  'z').
* string of grammar symbols: lowercase Greek letter (α, β, γ, ...).

'Derivation' is the process of starting with the start nonterminal symbol of a
grammar and successively replacing a nonterminal symbol by the body of one of
its productions.  If the leftmost (or rightmost) nonterminal is always
replaced, then it's a 'leftmost derivation' (respectively, 'rightmost
derivation').  When a sequence of derivation steps rewrite α~1~ to α~n~, we
say α~1~ 'derives' α~n~.  The symbol => means ``derives in one step''. With a
Kleene star above it means ``derives in zero or more steps'', with a plus
above it means ``derives in one ore more steps'', with an 'lm' below it means
``leftmost derivation'', with an 'rm' below it means ``rightmost derivation''.
If α derives from S, where S is the start symbol of α grammar G, we say that α
is a 'sentential form' of G.  When S derives α by a leftmost derivation, then
we say that α is a 'left-sentential form' of the grammar at hand.  Analogous
for 'right-sentential form'.  Rightmost derivations are sometimes called
'canonical' derivations.  A 'sentence' of G is a sentential form with only
terminal symbols, possibly none.  A language that can be generated by a
grammar is said to be a 'context-free language'.  If two grammars generate the
same language, the grammars are said to be 'equivalent'.

A 'parse tree' (aka 'concrete syntax tree') is a graphical representation of a
derivation that filters out the order in which the productions are applied to
replace nonterminals.  Each interior node represents the application of a
production and is labeled with the head.  I.e. each interior node represents a
nonterminal.  The children are labeled, from left to right, by the grammar
symbols in the body.  The leaves of a parse tree, read from left to right,
constitute a sentential form, called the 'yield' or 'frontier' of the tree.
See also abstract syntax tree for a similar concept.

Every parse tree has associated with it a unique leftmost and a unique
rightmost derivation.  An 'ambiguous' grammar is one that produces more than
one leftmost derivation or more than one rightmost derivation for the same
sentence.

A grammar is 'left recursive' if it has a nonterminal A such that there is a
derivation A =>+ Aα for some string α.  'Immediate left recursion' is where
there is a production of the form A -> Aα.

'LL(1) grammar class': The first L stands for scanning the input from left to
right, the second L stands for producing a leftmost derivation, and the 1 for
using one input symbol of lookahead.

??? those properties are those of a machine doing derivations, not of the
grammar itself???

'Bottom-up parsing' is the process of 'reducing' a string of terminal symbols
to the start nonterminal symbol.  A 'reduction' is by definition the reverse
of a step in a derivation.

In an '(Abstract) syntax tree (AST)' each interior node represents an
operator; the children of the node represent the operands of the operator.
Any (programming) construct in the source language is handled by making up an
operator for the construct and treating as operands the semantically
meaningful components of that construct.  AST and parse tree (aka concrete
syntax tree) resemble each other.  However in an parse tree interior nodes
represent nonterminals.  Not all nonterminals represent programming
constructs, e.g. they are just ``helpers'' of one sort of another, thus in an
AST they are not needed and are hence dropped.

A 'Syntax-directed definition (SDD)' is a grammar extended as follows: A set
of attributes is associated with each grammar symbol and zero or one semantic
action is associated with each position in a production rule.  An 'attribute'
is any quantity.  A 'semantic rule' (aka '(semantic) action') computes the
values of the attributes associated with the symbols appearing in the
production.  Typically, there is a semantic action at the end of a production
rule.  By convention, semantic actions are enclosed with curly braces.  A
'S-attributed' SDD is one that involves only synthesized attributes.
Informally, an 'L-attributed' SDD is one where in the dependency-graph edges
can only go from left to right, but not from right to left.  An 'attribute
grammar' is an SDD without side effects.  An 'annotated parse tree' is a parse
tree showing the value(s) of its attribute(s).

A 'Syntax-directed translation scheme (SDT)' is a context free grammar
semantic actions (aka program fragments) embedded within production bodies.
Alternatively defined, an SDT is a complementary notation to SDD.  A 'postfix
SDT' is one with all actions at the right end of the production bodies (and
also an underlying S-attributed SDD, or is that implicit?).

Ordering the evaluation of attributes in general: create a dependency graph
from the annotated parse tree, do a topological sort, evaluate attributes in
that order.  When an SDD is S-attributed, we can omit the topological sort and
just evaluate the attributes in any bottom-up order, the postorder traversal
being especially simple.  Specifically, postorder corresponds exactly to the
order in which an LR parser reduces a production body to its head.

Conversion from one type to another is said to be an 'implicit conversion'
(aka 'coercion') if it is done automatically by the compiler.  An 'explicit
conversions' (aka 'cast') is one where the programmer must write something to
cause the conversion.  'Widening conversions' preserve information.
'Narrowing conversions' can lose information.


== Bison

+YYSTYPE+:: User definable macro defining C data type of semantic values.
Defaults to +int+.


== Flex

+YY_DECL+, by default +int yylex()+, declares the scanning routine.  When
called it executes the user's code he put within ++%{ %}++ at the beginning of
the ``rules'' section of the flex input.  When called for the first time, it
executes +YY_USER_INIT+.  It scans from +yyin+ (global input file, by default
stdin). When it find more than one match, it takes the longest match, which
includes the `trailing part' of trailing context rules.  The match is made
available in +yytext+ (global char* by default) and +yyleng+ (global
int). +YY_USER_ACTION+ is executed.  The user provided action associated to
matched rule is executed.  That action typically ends in an return statement.
If no match is found, the `default rule' is executed and the `offending
character' is considered matched and copied to stdout.  The remaining input is
scanned for another match -- however as said, typically the user actions end
in an return statement.



== Other terminologies

=== Bison

token type name:: Bison's term for token name from lexer viewpoint, terminal
symbol from grammar viewpoint.
grouping:: Bison's term for nonterminal symbol.
semantic value:: Bison's term for attribute value of token ??? or is it attribute
semantic action:: Bison's term for semantic action.
Bison parser:: The program, being a parser, being the main output of Bison
(utility).
Bison parser implementation file:: The source code of a bison parser.
Generated by Bison (utility).
