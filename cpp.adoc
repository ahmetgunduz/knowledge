:encoding: UTF-8
// The markup language of this document is AsciiDoc

= C&plus;&plus;

This is about the rules and terms of the C&plus;&plus; programming language. It is my summary of the C&plus;&plus; standard.  Best practices / guidelines are in +programming_practices.txt+ and ++cpp_guidelines.txt++.


== Expressions / Object / Value categories

An _object_ is a region of storage (simplified). Don't confuse with notion of
class object.  Functions (although it often occupies storage), references,
classes and other types, namespaces, enumerators, and templates are not
objects.  Std [intro.object] ... An object is created by a definition (3.1),
by a new-expression (5.3.4) or by the implementation (12.2) when needed.  ...

An _expression_ is a sequence of operators and their operands.  The operands
of any operator may be other expressions or primary expressions.  Each
expression has some non-reference type, and each expression belongs to exactly
one of the tree primary value categories.  _Literals_ and _identifiers_ are
primary expressions.

=== Value categories

Introduction and description of all value types:

lvalue;; Identifies a non-temporary object or a non-member function.
Properties: Those of glvalue, address may be taken, can be lhs operand of
built-in assignment operator unless non-modifiable, may be used to initialize
an lvalue reference.  Note that an lvalue can be non-modifiable.  Flori:
Examples for lvalues which don't have a name: literal string, objects on heap,
array elements

prvalue (pure rvalue);; A temporary object or a value that is not an object.
Properties: those of rvalue, cannot be polymorphic, a non-class prvalue cannot
be cv-qualified, cannot have incomplete type

xvalue;; Simplified: Things whose return type is an rvalue reference.
Properties: those of rvalue, those of glvalue.  [Flori: Saying it's about an
eXpiring object is misleading IMHO, since that also applies to rvalues in
general.]

Mixed value categories:

glvalue (generalized lvalue);; Properties: May be polymorphic, ... (few more).

rvalue;; Flori's words: Hence if we do have an (rvalue) reference to it, we can do with it what we want (since nobody will care),
except for bringing it into an invalid state, in order that the ctor can run
without errors)).  Properties: Address can't be taken, can't be used as lhs of
the built-in assignment operator, may be used to initialize a const lvalue
reference or a rvalue reference [that's the point which makes it movable].
Flori's note: Note that although the address can't be taken, we still can
initialize references, so internally the compiler can take the address.  Note
that it can be the lhs of an overloaded assignment operator.

The same information presented other way round: Which expressions has which value type:

|===
| Literal string                                                 | lvalue
| Function                                                       | lvalue (*to-do*: but it is not an object, how does that fit together?)
| Cast to rvalue reference to function                           | lvalue
| Variable                                                       | lvalue
| Lambda                                                         | prvalue
| Literal, not string                                            | prvalue
| Function / overloaded operator call / cast when return / cast-to type is an lvalue reference  | lvalue
| Function / overloaded operator call / cast when return / cast-to type is not a reference  | prvalue
| Function / overloaded operator call / cast when return / cast-to type is an rvalue reference to object type  | xvalue
| builtin operators: pre inc/dec, dereference, (compound) assignment, subscript (except on array xvalue), comma when if the rhs is lvalue, ternary if 2nd and 3rd are lvalues, ... (*to-do*) member stuff | lvalue
| builtin operators: post inc/dec, arithmetic, logical, comparison, address-of, comma when rhs is rvalue, ternary when either 2nd or 3rd is not lvalue, ... (*to-do* member stuff) | prvalue
| ... (*to-do*: member stuff) | xvalue
|===

Visualization of how the value categories relate to each other:

----------------------------------------------------------------------
                                 C++11
                                   | As Venn diagram
         i !m     i m      !i  m   |     __________ ___________
primary: lvalue   xvalue   prvalue |    /           X           \
             \     /   \    /      |   /           / \           \
mixed:       glvalue   rvalue      |  |   lvalue  | x |  prvalue  |
             i         m           |   \  (part)   \ /   (part)  /
                                   |    \___________X___________/
legend: i: has identity            |     glvalue          rvalue
        m: movable                 |     (whole)          (whole)
-----------------------------------+----------------------------------
                                 C++98  _______      ________
         lvalue        rvalue      |   /        \   /        \
                                   |  |  lvalue  | |  rvalue  |
                                   |   \________/   \________/
----------------------------------------------------------------------

=== Misc

The only really new value category C&plus;&plus;11 introduced is xvalues. The
`new' value categories glvalue and prvalue are only to name different `new'
regions of the Venn diagram which emerged due to the introduction of xvalues.
xvalues in turn were added as a consequence of the addition of rvalue
references.

++return _expression_;++: Returning by value may involve construction and
copy/move of a temporary object, unless copy elision is used.  Flori's
abbreviation: if the expression is an lvalue it is tagged to be an rvalue
(*to-do*: xvalue or prvalue ?) so the move constructor or copy constructor
taking reference to const may be taken.
http://en.cppreference.com/w/cpp/language/return

+std::move+ doesn't move and +std::forward+ doesn't forward. +move+ is an
__un__conditional cast to rvalue, and +forward+ is an _conditional_ cast to
rvalue. When +move(x)+ is passed as an argument to a function/operator, it's
nearly certain that +x+ gets modified (else the move semantics woudn't make
sense, and if there is no move semantic overload, wrapping in +move+ makes no
sense). When implementing +foo(T&&)+, technically the same thing as in
+foo(T&)+ can be implemented. The ++T&&++ case however, in contrast to ++T&++
case, is allowed to take advantage of the fact that the caller does not need
the information stored in the object anymore; the caller only needs the object
to be in a valid state; he still needs to call at least the destructor. The
++T&&++ implementation usually steals the guts while ensuring the object is
still in a valid state.



*to-do*: Questions:

- What does prvalue description fragment ``a value that is not an object''
  mean?
- What is the purpose of the new value category xvalue (and the resulting
  glvalue and prvalue). They are not needed for move semantics, because
  distinction rvalue to lvalue already defines whether it's movable or not.

References:

- http://stackoverflow.com/questions/3601602/what-are-rvalues-lvalues-xvalues-glvalues-and-prvalues
- <<TCppPL>> Chapter 6.4
- <<http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3055.pdf,n3055 >>
- http://en.cppreference.com/w/cpp/language/value_category


== References

C&plus;&plus;11 adds rvalue references.  Now we can also modify rvalues
through them.  *To-do*: Are my words correct?: rvalue reference has the
semantic of: I can modify they content in any way; however nobody will see the
change since nobody will reference thee again (except for destructor and methods which only write but do not read before writing).  So the modification typically is stealing what ever thou owns.
The only constraint is that I must leave you in a valid state so your
destructor and assignment operator (*to-do*: why assignment?)  can run.  An
lvalue reference can naturally do the same modifications, but it cannot bind
to rvalues; The use case of stealing from rvalues is much more common (since
they are never used again after the stealing) than stealing from lvalues
(since they might be used again after that stealing).

Which expressions can bind to which references. P__n__ is, in the field of
overload resolution, about which is a better match; a smaller number is a better
match than a higher number.

|===
|                                       | mut lvalue | immut lvalue | mut rvalue | immut rvalue
| ++T&&++: rvalue reference             |            |              | y (*) P1   |
| ++const T&&++: const rvalue reference |            |              | y (#) P2   | y (#) P1
| ++T&++: lvalue reference              | y P1       |              |            |
| ++const T&++: const lvalue reference  | y P2       | y            | y P3       | y P2
|===

(*) The one important change in C&plus;&plus;11.  Having rvalue references we
can also bind to mutable rvalue and modify it through the reference.  Using
++const T&++ we could already bind to rvalues before, but we could not modify
them through the reference.

(#) Const rvalue references are also new, but in general not really useful,
with const lvalue references we can already bind to rvalues.

When there are multiple y in a column, overload resolution must choose between
the multiple viable overloaded methods. Concerning the cases of th above table, the rules for which viable match is better : 1) rvalue reference is better than an lvalue reference 2) less cv-qualified is better.


== Initialization


C&plus;&plus;11 adds _uniform initialization_ using the brace syntax. Unlike C&plus;&plus;98's different syntaxes of initialization, it an be used anywhere (locals, members, statics etc.) an express anything (e.g. now we also can initialize collections).

--------------------------------------------------
// C++98
rectangle        a(origin(),extends());  // oops, vexing parse
complex<double>  c( 2.71828, 3.14159 );
mystruct         m = { 1, 2 };
int              a[] = { 1, 2, 3, 4 };
vector<int>      v;                              // urk, need more code
for( int i = 1; i <= 4; ++i ) v.push_back(i);    //   to initialize this

// C++11 (note: "=" is mostly optional)
rectangle       w   = {origin(), extents()};
complex<double> c   = {2.71828, 3.14159};
mystruct        m   = {1, 2};
int             a[] = {1, 2, 3, 4};
vector<int>     v   = {1, 2, 3, 4};
--------------------------------------------------

Some rules

- Uniform initialization prohibits narrowing conversions.

- "T foo = bar" (copy initialization) means the same as "T foo(T(bar))" (conversion to T, then copy or move ctor using the temporary).

- "T foo = \{bar}" (copy list initialization) is the almost same as "T foo\{bar}" (direct initialization), only that the former can't use explicit ctors.

- If there is at leas one std::initializer_list ctor, and using the uniform initialization, it is _strongly_ preferred over other ctors; if there is any way to call it, it will be called. E.g. if a class has a ctor with signature "(int, bool)" and a ctor "(std::initializer_list<long double>)", the initializer "{10, true}" calls the initializer list constructor by converting the arguments to long double. Say in the previous example the class also has a convertion operator "operator float() const" and a copy ctor and a move ctor. Then, say x is of the class' type, the initializers "\{x}" and "{std::move(x)}" will both call the initializer list ctor, as opposed to the copy ctor or the move ctor respectively.

- An empty ++{}++ list as initializer calls the default constructor if both the default ctor and the std::initializer_list ctor are available. If you want to call the std::initializer_list ctor, use "foo({})".

- See <<auto_type_deduction>>.

- _Most vexing parse_: The standard says ``If it can be a function declaration, it is.''. Thus both of the following are function declarations, not object definitions: ++T obj();++ and ++T obj(foo(),bar())++, given foo and bar are types. Another reason not to use initializers based on parens.

- zero initialization: static T t; T(); T t = {}; T t{}; *to-do* more details https://en.cppreference.com/w/cpp/language/zero_initialization

Guidelines:

- If you provide an initializer-list constructor, also provide a default constructor with the same semantics as though you were initializinng with a zero-size initializer_list.

- Scott Meyers: Choose between either using uniform initalization by default and resort to paranthesis when you must, or vice verca, and then be consistent.

- Herb Sutter: Use uniform initialization by default and resort to parenthesis when you must, but those cases should be rare.


References:

- http://herbsutter.com/2013/05/09/gotw-1-solution/

- Book "Effective Modern C&plus;&plus;", Chapter 3


== auto

See also <<auto_type_deduction>>.

++auto foo = ...++ vs ++const auto& = ...++ or ++auto&& = ...++

- The general pattern ``avoid creating unnecessary objects'' suggest using the late

- For the former to compile, the type of the initializer must be copy-able. A restriction the later doesn't have.

- in the case initializer is a call returning a refernce to some internal object, e.g. +at()+ of containers: foo is a copy, and modifying foo does not modify the original object, which might not be what was intended

References:

- http://herbsutter.com/2013/06/07/gotw-92-solution-auto-variables-part-1/
- Scott Meyers, Effictive Modern C&plus;&plus;, Item 5 6 41
- Stephan T. Lavavej: https://github.com/CppCon/CppCon2014/tree/master/Presentations/STL%20Features%20And%20Implementation%20Techniques



== Type deduction

Recall that temporary objects are (non-const) rvalues, and that there are no
const rvalues (only 99% sure about the latter statement). Also recall after declaring a reference, e.g. "int& ri = i;", the expression "ri" in almost all cases means the referee, and thus is of type int, not int&.

Function template type deduction (since C&plus;&plus;98):

--------------------------------------------------
int i = 42;
const int ci = 42;

template<typename T> void f(T);
        // arg's value category     T           param's type
f(i);   // lvalue                   int         int
f(ci);  // const lvalue             int         int
f(42);  // rvalue                   int         int

template<typename T> void f(T&); // T* is analous
        // arg's value category     T           param's type
f(i);   // lvalue                   int         int&
f(ci);  // const lvalue             const int   const int&
f(42);  // rvalue                   compile error, lvalue expected

template<typename T> void f(const T&); // const T* is analogous
        // arg's value category     T           param's type
f(i);   // lvalue                   int         const int&
f(ci);  // const lvalue             int         const int&
f(42);  // rvalue                   int         const int&

template<typename T> void f(T&&); // template param's type is universal reference
        // arg's value category     T           param's type
f(i);   // lvalue                   int&        int&
f(ci);  // const lvalue             const int&  const int&
f(42);  // rvalue                   int         int&&
--------------------------------------------------

In the pass by value case (f(T)) with a const lvalue argument, the const is
dropped since the parameter is an independent object.  In the pass by reference
/ pointer cases (f(T&) or f(const T&)), the result is such that the type of the
referee / pointee matches from both viewpoints (argument and parameter).

[[auto_type_deduction]]
Type deduction with auto, added in C&plus;&plus;11, works by definition the same as function template type deduction, see following code snipet, with one exception: In "auto foo = \{42};" the type of foo is std::initializer_list<int>, opposed to int as function template type deduction would do it.  Note that in "auto foo\{42};", the type of foo is int (corrected by N3922, a defect of C++11. Without N3922, the type is std::initializer_list<int>).

--------------------------------------------------
// function template            // auto type deduction
// type deduction
template<typename T>            ...auto... foo = expr;
void f(...T...);
f(expr);
--------------------------------------------------



References:

- Type deduction and why you care, by Scott Meyers.
  https://www.youtube.com/watch?v=wQxj20X-tIU[Video],
  https://github.com/CppCon/CppCon2014[Presentation]

- Book "Effective Modern C&plus;&plus;", Chapters 1-4


== Undefined behaviour

- http://en.cppreference.com/w/cpp/language/ub
- https://blog.regehr.org/archives/1520[Undefined Behavior in 2017]
- https://www.youtube.com/watch?v=v1COuU2vU_w[CppCon 2017: John Regehr “Undefined Behavior in 2017 (part 1 of 2)”]
- https://www.youtube.com/watch?v=yG1OZ69H_-o&t=1215s[CppCon 2016: Chandler Carruth “Garbage In Garbage Out: Arguing about Undefined Behavior"]
- https://www.youtube.com/watch?v=g7entxbQOCc&t=2340s[CppCon 2016: Michael Spencer “My Little Optimizer: Undefined Behavior is Magic"]
- http://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html[What Every C Programmer Should Know About Undefined Behavior #1/3]


== Bibliography

- [[[TCppPL]]] The C&plus;&plus; programming language, 4rd edition.

//  LocalWords:  TCppPL eXpiring rvalues xvalues prvalues pre dec Flori
