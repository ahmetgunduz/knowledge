My opioninion, backed by git manuals & linus: To fastest, easiest and most
relyable way for an engineer to learn to work with Git is to understand the
immutable DAG of commits, more precisely the immutable DAG of Git objects and refs.

Its about that the UI is a DAG of versions (commits), and refs (branches,
tags) pointing to. It's not about Git's internal; the DAG is on the UI.

Quote:
- git user manual: Git is built on a small number of simple but powerful ideas. While it is possible to get things done without understanding them, you will find Git much more intuitive if you do.
- look it up: linus: the internal data structures are really really simple
- Most Git man pages, within the intro what a subcommand do, explain in in
  terms of the DAG.

- Git User Manual (being an intro to git): chapter git concepts, in the middle, i.e. its not about internals, tells about DAG of git objects
- git-scm: Chapter 3 (of 10) tells about Git Objects and partly about the DAG



- Commit graph, i.e. a set of contents / file trees, i.e. no diffs saved logically, i.e. no renames/copies saved
- Making a (non-merge) commit: adding a new commit (with only one parent) to the graph
- Making a merge commit: adding a new commit (with two or more parents) to the graph. You also could have youst editet the working tree and made a commit specifying all its parents (e.g. edit .git/MERGE_HEAD, then commit).
- Cherry-pick: apply a patch
- Rebase: series of cherry picks
- fetch:
- pull: fetch + merge or rebase
- reflog: sequence of commit SHA1s
- stash: 2 (or 3) commits, referenced by stash's reflog
- cherry-pick = diff + apply (aka patch) that diff + commit

make a gaph/diagram:
--------------------------------------------------
pull -> fetch
pull -> merge [label="optionally"]
pull -> rebase [label="optionally"]
rebase -> cherry-pick [label="series of"]
cherry_pick -> diff
cherry_pick -> apply
cherry_pick -> commit [label="optionally"]
--------------------------------------------------

rebase = series of cherry-picks
cherry-pick = diff + apply (aka patch) that diff + commit
stash =
merge = merge(action) + optionally(by default) commit (with multiple parents, typically two)
merge(action) = merge/meld two or more differences. Base->A + Base->B
commit = add a commit to the DAG (possibly multiple parents)
apply (aka patch) = mody
diff = diff between two trees, often two commits
stage =

stash save = create two (three) commits: one for current working tree state,
  one for index, optionally one for untracked files. Stashes are identifed
  by their index in the sequence of stashes.
stash apply = apply the diff shashcommit-parent to stashcommit


- commit DAG <=> history



git-obj-demo / git-ref-demo: The purpose is to visualize/proof that it really is that
simple. The purpose is to to bother you with internal.

Knowing that's all about an immutable DAG of objs and refs helps to understand
that:
- What happens if you delete a branch. Are the commits lost for ever? (single ref vs multiple ref)
- Why is the old commit still there if you modify a commit message? (single ref vs multiple ref)
- Why are the old commits still there if you rebase? (single ref vs multiple ref)
- Whats the difference between 'git mv x y' and 'git rm x; mv x y; git add y' -- none
- What happens on a git fetch / push?
