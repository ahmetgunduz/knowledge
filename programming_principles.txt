:encoding: UTF-8
// The markup language of this document is AsciiDoc

= Programming Principles

dynamic polymorphism (aka inclusion / parametric polymophism)

generics aka static polymorphism

(explicit) interface vs class vs object, implicit interface as used by
C&plus;&plus; static polymorphism, syntactic vs semantic interface,
implementation of, instance of, messageb passing, .... see also gotw, what's
in a class -- the interface principle. An example of a free function (actually
an operator) where the class is not the first but the second parameter is the
canonical implementation of operator<<.

inheritance vs subtyping, Liskov

(class) invariants, preconditions, postconditions, (ref to semantic interface)

closure, lambda, (member) method, (member) function, procedure, class static
method, pure function, free (aka nonmember) function, tail call, functor,
function object, delegate, function/method pointer, instance method, field

call decl, cdecl, ...

internal, external linkage, linkage in general

abstraction

(pure) abstract class, virtual method, pure virtual method, interface in the
sense of Java

encapsulation

module, package, static / dynamic library

information hiding

static vs dynamic binding, binding in general

API

ABI, binary compatibility

From operating_systems.txt: threads, processes, active object, concurrency,
race condition, critical section, locks, semaphores, monitors, mutex,
reentrant, reentrancy, thread safe, cache contention / coherence ...

building, compiling, linking, JIT,

== Memory / dynamic memory management

The malloc family of dynamic memory management functions internally build on
top of virtual memory regions provided by the kernel: typically a contiguous
heap and a set of pages via anonymous memory mapping.

In case of POSIX, the heap's size can be adjusted via the brk (program break)
and sbrk system calls.  Note that technically only it's end address can be
modified, i.e. it's a contiguous virtual memory region, i.e. when there are
large free gaps between used heap regions, they can't be given back to the
kernel.

In case of POSIX, anonymous memory mapped pages can be mapped with the mmap
system call.

In C&plus;&plus;, double delete is undefined behavior: https://isocpp.org/wiki/faq/freestore-mgmt#double-delete-disaster, http://stackoverflow.com/questions/9169774/what-happens-in-a-double-delete.

In C&plus;&plus;, all pointers into a freed memory region are invalidated: http://en.cppreference.com/w/cpp/memory/new/operator_delete.

- malloc(3). The notes section says that under the hood sbrk and mmap is used.
- brk(2) / sbrk(2) (C POSIX library, system calls)
- http://duartes.org/gustavo/blog/post/anatomy-of-a-program-in-memory/
- http://duartes.org/gustavo/blog/post/how-the-kernel-manages-your-memory/
- https://sploitfun.wordpress.com/2015/02/11/syscalls-used-by-malloc/



//  LocalWords:  sbrk mmap malloc brk fdisk mkdir loadkeys BSS TLS
