// The markup language of this document is AsciiDoc
:encoding: UTF-8
:toc:
:toclevels: 4


= XML

== Intro

_well-formed_: A well formed document adheres to the grammar. I.e. it is a member of the language (in the theoretical computer science meaning).

A _valid_ document is one that includes a document type declaration and satisfies the respective DTD. Otherwise the document is said to be _invalid_; however one typically says that checking for validity requires a DTD.

Simplification of SGML.

Misc: case-sensitive. Loosely speaking, doesn't care about whitespace.

_document_: Must have exactly one root element. May optionally start with an "xml" preprocessing instruction. The _root element_ (or _document element_) is the one element that does not have a parent.

_element_: <foo [attributelist]>...</foo>. <foo> is an _start-tag_, </foo> is a _end-tag_. Everything between the start-tag and the end-tag (exclusive) is called the element's _content_. Whitespace is part of the content. An _empty element_ is one that has no content. It's syntax is like so: <foo [attributelist]/>.

The content is generally a mixture of _text_ (or _character data_) and child elements. Elements containing only text are said to have _simple content_, elements containing only child elements are said to have _complex content_, and elements containing both are said to have _mixed content_.  Elements containing nothing (not even whitespace) are called _empty_. Text may not contain the literals "<" and "&".

Simple content = text (but no child elelements)

complex content = child elements (but no text)

mixed content = both child elements and text


_CDATA section_: <![CDATA[...]]>. For literal text (aka verbatim).

_attribute list_: List of attributes. Each _attribute_ is a name-value pair like so: attributename="attributevalue" or attributename=\'attributevalue'.  You can use references within attribut values.  Attribute values may not contain the literals "<", "&" or the character denoting the end of the string (i.e. single or double quote).  Attributenames cannot be repeated in the same list.

_XML Names_ (applies to all sort of names, tag names, attribute names etc.): Composed of ASCII {alphanumeric, underscore, dash, point} and Unicode letters, numbers, and ideograms. However may not start with {numbers, dash, point}.  Names starting with "xml" (independent of case) are reserved for W3C. XML names are case sensitive.

_entity references_: \&foo; There are exactly five: "lt" -> <, "gt" -> >, "apos" -> ', "quot" -> " and "amp" -> &.

_numeric character references_: \&#x...; where "..." is a unicode code point in hex. Leave out the "x" and its in decimal.

_references_ in general: Can appear in attribute values and element content.

_comment_: <!--...--> Cannot contain "--", which also rules out an comment ending like so "-\->". Comments may appear at the document top level and within element content. Comments are markup, i.e. an application reading an XML document will see it after the parser. However when a computer program should interpret the XML document, you should prefer processing instructions over comments. Comments can appear anywhere outside a tag.

_processing instruction_: <?foo ...?>. To pass information to an application processing the XML document. `foo' is an XML name called the _target_, possibly the name of the application for which this processing instruction is intended, or possibly the name of this particular processing instruction. The rest, up to "?>", is anything. Processing instructions can appear anywhere outside a tag.

The _XML declaration_ looks like a processing instsruction with target foo, but is not a processing instruction, but really just a thing called the XML declaration.  XML documents should beginn with an XML declaration, but are not required to. If there is one, it must be the first character in the document; not even whitespace may precede it.  Thus the XML parser can make reasonable guesses about the document's character encoding by reading the first 5 characters ("<?xml"). The `standalone' attribute should be set to `yes' if the document has an external DTD.

_About character encoding_: By default XML documents are assumed to be encoded in UTF-8. This can be overwritten by an _encoding declaration_ inside the XML declaration like so encoding="ISO-8859-1".

Language ecosystem:

|=====
|                | XML    | JSON
| Navigation     | XPath  | JSONPath, JSONSelect
| Transform      | XSLT   | JSONT
| Query          | XQuery | XQuery, JSON Query, JSONiq
| Update, Script | XQuery | JSONiq
|=====


== Namespaces

_XML Namespaces_: <foo xmlns:bar="fred-uri"> Defines "bar" to be a _namespace binding_ (aka shorthand) for the _namespace name_ "fred-uri". The scope is the foo element itsels and it's descendants.  Within the scope the namespace can be used by prepending "bar:" to a _local name_, e.g. "lorem", resulting in the _qualified name_ (or _QName_, ot _raw name_) "bar:lorem". "bar" is then called a _prefix_.  The prefix is really just a shorthand, i.e. when comparing qualified names, what matters is the pair (uri, local name). Prefixes are XML names.  _default namespace_: In the namespace binding definition, the prefix can be absent (xmlns="fred-uri"). Any local tag name (i.e. default namespace does not apply to attribute names) in the tree without prefix will take that namespace.

By default you already get namespace "xml". It contains e.g. "lang" or "id". See https://www.w3.org/XML/1998/namespace.

Style guide: Put all namespace bidnings in the root element. Rational: It's simpler to understand.



== Document Type Definitions (DTDs)

Old schema for XML. Superseeded by XML Schema.

DTDs are written in a formal syntax that explains precisely which elements may appear where in the document and what the elements’ contents and attributes are.  A valid document includes a reference to the DTD to which it should be compared. This is given in the document’s single _document type declaration_, which looks like this: <!DOCTYPE person SYSTEM "foo-uri">, where foo-uri refers to the file containing the DTD. You also can make the DTD inline, called _internal DTD subset_, by using <!DOCTYPE person [...]>. The SYSTEM "foo-uri" is called _external DTD subset_.  Both of the two can appear in the document type declaration. As a general rule, the two different subsets must be compatible. Neither can override the element declara- tions the other makes. For example, name.dtd cannot declare the person element because the internal DTD subset already declares it. However, entity declarations can be overridden.

DTDs don't know about XML namespaces (because DTD predate the introduction of XML namespaces). foo:bar is just some valid name.

<!ELEMENT foo content_specification> is an _element declaration_ for the element named foo. content_specification is an expression composed of the following operators and terminals.

Expression operators (as in regex): ?, *, +, |, (), concatenation (ordered) is with comma

Terminals: EMPTY (empty element), #PCDATA (parsed character data; mixed content can only be specified by a choices list (pipe operator) with #PCDATA as first element), ANY (element is always valid), foo (element named foo).

<!ATTLIST elementname attribute_specification+> is an _attribute declaration_ for element elementname. Each attribute specification looks like "attributename type attribute_default"

Attribute types:

CDATA:: Any well-formed text

NMTOKEN:: XML name token, which is not the same as an XML name. A string constituting a valid XML name, however without the restriction that the first character must be a subset of the characters that's allowed elsewhere in the name.

NMTOKEN:: Whitespace separated list of NMTOKEN

(...|... ...):: Enumeration; pipe separated list of NMTOKEN.

ID:: An XML name (not XML name token) being an unique within the document. I.e. no other ID type attribute in the document can have the same value. Since numbers are not valid XML names, often an underscore is used as prefix in the document for the value of an ID type attribute.

IDREF:: Reference to an ID

IDREFS:: Whitespace separated list of IDREF.

ENTITY:: Is actually not about attributes; *to-do*

ENTITIES:: Whitespace separated list of of ENTITY.

Attribute defaults:

#REQUIRED:: Attribute must occur exactly once

#IMPLIED:: Attribute is optional

#FIXED value:: The attribute value is the specified value. If the document explicitely states the attribute, it must have the specified value.

value:: Use the specified value as default.


=== General Entity Declarations

<!ENTITY name value!> is an _internal ENTITY declaration_, declaring `name' as an abbreviation for `value', the same way XML character entities work.  The value is enlosed in either single or double quotes.  The value can contain markup; however the value must be well-formed.  It can contain entity references that are resolved bevore the text is replaced. Self-referential and circular references are forbidden, however.

<!ENTITY name SYSTEM "foo-uri"> is an _external parsed ENTITY declaration_, declaring `name' as an abbreviation for the content of the file identified by foo-uri. References to external entities are not allowed in attribute values.  Note that a parser is not required to resolve an external entity reference; the XML standard gives it some leeway.  Loosely speaking, the content must be well-formed.

The external entity document may start with a _text declaration_, which practically looks and feels the same as an XML declaration <?xml encoding="MacRoman">.  It is mostly about the encoding attribute to specifiy the encoding of the external entity document.  There is no `standalone' attribute however.

_external unparsed entities_ are a way of embedding any data, text or binary, into an XML document.


== XML Schema

Newer, alternate, more powerful technology relative to DTD. Uses XML syntax. Provides namespace http://www.w3.org/2001/XMLSchema. By convention you should bind it to prefix "xs" in your schema. By convention schema files have file extension "xsd".

The document containing the schema is called the _schema document_.  An XML document described by a schema is called an _instance document_.  If an instance document satisfies all the constraints specified by the schema, it is considered to be _schema-valid_.

To associate a schema with an XML document, use an xsi:noNamespaceSchemaLocation or xsi:schemaLocation  attribute on an element and set the attribute value to the schema's uri, where xsi is a prefix bound to http://www.w3.org/2001/XMLSchema-instance. You can also explicitely give a validation parser both the XML document and the schema.

Bind a prefix, commonly xs, to namespace http://www.w3.org/2001/XMLSchema. The root element of a XML schema must be the xs:schema element.

Elements are declared using the xs:element element. The `name' attribute of xs:element specifies the name of the target element. The type of the target element is either specified via the `type' attribute of the xs:element, or via child elements of xs:element. An element that is declared to have a simple type cannot have any attributes.

There are a number of built-in simple types. Such as string, Name (XML name), integer, boolean, anyURI, ....

Attributes are declared using the xs:attribute element. Attributes are optional by default. To specify that the attribute is required, use the `use' attribute, and set it to "required". The `default' attribute lets you specifiy a default value. The `fixed' attribute lets you specify a value that is automatically assigned to the attribute which cannot be overwritten.


=== Namespaces

To associate a namespace to a schema, specify the namespace's URI as value of the targetNamespace attribute of the xs:schema element. In the instance document, set the value of the xsi:schemaLocation attribute to "namespace-uri schema-uri", where namespace-uri must match the URI specified as value of the targetNamespace attribute in the schema.  The elements and attributes specified in the schema are in the specified namespace.

--------------------------------------------------
<xs:schema ... targetNamespace="http://mynamespace">
  <xs:element name="myelement" ...>...<xs:element>
</xs:schema>

<myprefix:myelement ...
  xsi:schemaLocation="http://mynamespace myschema.xsd">
  xmlns:myprefix="http://mynamespace">
  ...
</myprefix:myelement>
--------------------------------------------------

If the schema is not associated with an namespace, the specified elements and attributes are in no namespace.



=== Types

Types form a _type hierarachy_. An edge in the tree represents derivation. There are are four kinds of _derivation_: _restriction_ (limits the allowed content of the base type), _extension_ (adds to the allowed content of the base type), _list_ and _union_. _anyType_ is the root. From it derive all complex types, and the type _anySimpleType_, which is the root of the subtree of simple types. A _simple type_ cannnot have element children or attributes, where as a _complex type_ can. Complex types are divisible into two kinds: simple content and complex content (where here the term `complex content' doesn't yet specify wether or not it includes mixed content, see attribute `mixed' of xs:complexType).

The default syntax for complex types is complex content that restricts anyType. That is the following

--------------------------------------------------
<xs:complexType name="myType">
  ...
</xs:complexType>
--------------------------------------------------

is an abbreviation for the following

--------------------------------------------------
<xs:complexType name="myType">
  <xs:complexContent>
    <xs:restriction base="anyType">
      ...
    </xs:restriction>
  </xs:complexContent>
</xs:complexType>
--------------------------------------------------

New types are defined using xs:complexType or xs:simpleType elements. They can be `inline', i.e. child of an xs:element.  They can be `global', in which case they must be named via a name attribute.  That name lives in the target namespace of the schema.  They can then be used as value for the type attribute of an xs:element element or xs:attribute element.

xs:element s can have the attributes minOccurs and maxOccurs, which define how many times the element can be repetead, analogous to quantifiers in DTDs / regexes. Both default to 1. maxOccurs can also have the value unbounded.

empty element: Via xs:complexType (and implicitely or explicitely xs:complexContent) containing no xs:element childs (but possibly xs:attribute childs).

simple content and no attributes: xs:simpleType

simple content and attributes: xs:complexType and within it xs:simpleContent.

complex content: xs:complexType, attribute `mixed' at default "false", and implicitely or explicitely xs:complexContent.

mixed content: xs:complexType, attribute `mixed' set to "true", and implicitely or explicitely xs:complexContent.


facets: *to-do*

xs:sequence: The elements the refered to element contains must appear in exactly the same order which which they appear within the xs:sequence element.

xs:choice: The refered to element must contain exactly one of the child elements of xs:choice.

xs:all: The refered to element must contain each of the listed child elements exactly once, in any order.


== XPATH

XPath is a non-XML language for identifying particular parts of XML documents.

From the perspective of XPath, the XML document is a tree made up of nodes, where there are the following kinds of nodes: Root (representing document, not root element), element, text, attribute, comment, processing-instruction, namespace. Thus notably CDATA sections, references, the document type declaration and the XML declaration are already washed away by the parser.  The root node represents the entire document, that is _not_ the document's root element.

The xmlns and xmlns:foo attributes are not considered attribute nodes. Instead, the respective information is within a namespace node, which is attached to _every_ element node which is in the scope of the binding.


=== Location paths

A _location path_ is a subset of XPath expressions. A location path identifies a set of nodes. A location path is built out of successive location steps. Each _location step_ is evaluated relative to a particular node in the document called the _context node_. Which node currently the context node is, is specified by the application using XPath. Every location step is composed of an axis test, a node test, and optionally a predicate.  In an abbreviated location path, the axis test and the node test are combined.  In an unabbreviated location path, they are separated by a double colon (::). "child::people" selects along the element child axis all people elements.  "attribute::foo" selects along the attribute axis all foo attributes.

_available axes_: child element (foo), parent (..), self (.), attribute (@foo), descendant-or-self (//), descendant, ancestor-or-self, ancestor, following-sibling, preceding-sibling, following, preceding, namespace.

_Root location path_: The root node in the XPath tree is identified by a forward slash "/".

_Child element location step_: An XPATH being a single element name refers to the set of child elements of the context node with the specified namae.

_attribute location step_: Analogously to the child element location step, but the name is prefixed by @.

_comment(), text(), processing-instruction()_ location step: Match the set of child elements of the context node being of the specified node type.

_wildcard_ location step: "\*" matches any child element. "foo:*" matches any child element in the namespace URI which the prefix foo refers to. "@\*" matches all child attribute nodes.  "@foo:*" matches all child attribute nodes in the namespace URI which the prefix foo refers to. "node()" matches all child nodes.

_compound path_: Constructed from location steps. Forward slash "/" moves down in the hierarchy. E.g. "/people" refers to the root element, here people. "/people/person" refers to all person child elements of the people element. "/people/person/name" refers to all name child elements of those. "." refers to the context node. ".." refers to the parent node of the context node. "//" refers to the descendants of the context node (inclusive). E.g. "person//@id" selects the id attributes of all elements rooted at all person child elements of the context node.

_alternation_: The pipe "|" denotes alternation. There is a match if either expression matches.

_predicates_: An location step refers to a set of nodes. You can filter that set, producing a new set, by providing a predicate expression which, when true, keeps the node. The syntax is to append "[expression]" to a location step. Relational operators are =, >, >=, <, \<=, and !=. For example "//person[@born\<=1976]" selects all person elements in the document whose born attribute has a numerical value of less than or equal to 1976. "//name[initial]" selects all name elements in the document which have at least one initial child element.  Boolean operators are "and", and "or". Predicate (sub) expressions that evaluate to numbers select the i-th element from the sequence, where counting starts at 1. E.g. "//foo[2]" selects the 2nd foo element of the document.

*to-do* XQuery does allow multiple predicates foo[...][...]... . Does XPath also?

*to-do* more details about how to use predicate to index a sequence. Note that indexing starts at 1, as oppose to zero as C/Java etc. How about ranges? How about multiple indicies.


=== General XPath expressions

Recall that a location path returns a node set. General XPath expressions can return numbers, Booleans and strings.

_numbers_: All numbers are floating point (8-byte IEEE 754, same as Java's double).

_strings_: Delimited by either single or double quotes. A string is an ordered sequence of Unicode characters. The operators = != can be used to compare strings.

_booleans_: Either true or false. There are no boolean literals, however you can use the XPath functions true() and false(). Operators are "and", and "or".

_basic arithmetic_: + - * div mod. The operators behave as their counterparts in Java.


== XQuery

A query is made of a two parts: an optional prolog and a body. The prolog contains declarations. The body is technically a single expression, however multiple expressions can be in a sequence, separated by commas. XQuery is functional and declarative.

The _query processor_ is the software that parses, analyzes and evaluates the query. The analisis is roughly equivalent to compiling a program; it finds static errors.

The _XQuery Data Model_ (known as the XQuery 1.0 and XPath 2.0 Data Model, or _XDM_): Everything is a sequence of items.  A _sequence_ is an ordered list of zero or more items. An _item_ is a generalization of a node and an atomic value. An _atomic value_ is a simple value with no markup associated with it. A _node_ is an XML construct such as an element or attribute. There are these six node kinds: document, element, attribute, text, proccessing instruction, comment, namespace (however XQuery does not provide access to namespace nodes).  Every node has a unique _identity_; identities can be compared with the is operator. XDM is not the same as the Infoset.

_names_: XQuery is case sensitive. Names must conform to the rules for XML qualified names.  There are no reserved words. XQuery is free space analogous to languages such as Java.

_variables_ are names prefixed by a dollar sign ($). Variables are immutable.

_comments_: Delimited by (: and :). Can be nested.

_expression_: Operands are always sequences (of items).

_namespaces_: \'declare namespace myprefix = "namespaceuri"'. Then myprefix can be used as prefix in QNames.


=== Types

XQuery is a strongly typed language. The type system is based on the type system of XML Schema. Thus all the built-in types such as xs:integer, xs:string etc. are available.

XDM vs Infoset: In XDM nodes can have types, in Infoset they are always strings.

_type hierarchy_. No value is ever of xs:anyAtomicType; they alwas have a more specific type.  See also https://www.w3.org/TR/xpath-datamodel-31/

--------------------------------------------------
xs:anyType
    (complex types)
       xs:untyped (contrast with xs:untypedAtomic)
       (user defined compex types)
    (simple types)
        xs:anyAtomic
            ... see below ...
        (list types)
            ...
        (union types)    
            ...
--------------------------------------------------

--------------------------------------------------
xs:anyAtomicType
    xs:untypedAtomic (contrast with xs:untyped)
    xs:boolean
    xs:decimal
        xs:Integer
            ...
    xs:float
    xs:double
    xs:string
        xs:normalizedString
            xs:token
            ...
    xs:QName
    xs:anyURI
    xs:hexBinary
    ...
--------------------------------------------------

_automatic casting_: Untyped values are automatically casted to the type required by an operation. *to-do* this seems not to be generally true, see value comparisons

_sequences_: Sequences are ordered. They can contain duplicates. A sequence with only one item is called a _singleton sequence_. There is no difference between a singleton sequence and a single item. Thus any of the functions / operators that operate on sequences can also operate on items. Note that sequences cannot be nested, since a sequence is an list of items, and a sequence is no item.

An atomic value can have a type or be untyped.

_nodes_: There are two values for a node: string and typed. All nodes have a string value. The string value of an element node is the character data content of itself and all its descendant elements concatenated together. The string value of other nodes are straightforward.  A schema may specify the type of a node.  The typed value of a node is according to that type.  If an element or attribute has not been validated it is automatically assigned xs:untyped.

_effective Boolean value_: false, 0, NaN, empty string, empty sequence count as false. Everything else generally true. *to-do*

_literal sequence_ ("foo", 42): Comma separated list of expressions, enclosed in parenthesis.

_string literal_ "foo" or \'foo': Either in double or single quotes.

_numeric literal_ 42 or 3.14: As in most programming languages.

Validating gives the nodes types, thanks to the schema, which specifies the types of nodes.

--------------------------------------------------
import schema namespace m = myuri at "myschema.xsd"
validate { <m:foo>...</m:foo> }
--------------------------------------------------


=== Operations

_arithmetic expression_ +,-,*,div,idiv,mod

_comparison expression / _general comparisons_ < \<= = != >= >: When comparing any two of the atomic types, if one is typed and the other is untyped, the untyped value is cast to the typed value's type. If both are untyped, they are compared as strings.

_comparison expression_ / _value comparisons_ lt le eq ne ge gt: Operate only on single atomic values (an atomic value, a node containing an atomic value or the empty sequence). If either operand is the empty sequence, the empty sequence is returned (analogous to null in SQL).  If both operands are untyped, they are compared as strings. If one is typed and the other is untyped, a type error is raised.

_comparison expression / _node comparisons_ is: Compares idendity. Each operand must be a single node or the empty sequence. If either is the empty sequence, the empty sequence is returned.

_comparison expression / _order comparisons_ << >>: order of elements in document *to-do*

_logical expression_: `and' and `or' are operators, `not' is a function. For each operand the effictive Boolean value is calculated.

_path expression_ /,//,..,.,child::,etc.: *to-do*

_constructor expression_ / _direct element constructor_ <foo>...</foo>: A literal element is just regular XML syntax. You can inject an _enclosed expression_ into character data or attribute value by enclosing it into curly braces <foo>lorem\{expr}ipsum</foo>. To use literal curly braces within an literal element, double them, i.e. {{ and }}. If an enclosed expression within the content of the element evaluates to a sequence of attributes, they become attributes of the XML element under construction.  Each atomic value in the sequence resulting from the enclosed expression is cast to xs:string and inserted as character data or attribute value respectively. Two adjacent atomic values are separated by space.  When an enclosed expression appears within an attribute value, then the string value of each node is inserted. E.g. <foo bar="<fred>42</fred>"/> results in <foo bar="42"/>.

_constructor expression_ / _computed constructor_ element (elementname | { nameexpr }) { contentexpr }, attribute (attributename | { nameexpr}) { valueexpr }.

_FLOWR expression_ for,let,where,order by,return,etc.: see <<flowr>>.

_quantified expression_ some,every,in,satisfies: (some|every) ($myvar in expr ",")+ satisfies expr. The middle part binds iteratively every item in expr (as always a sequence) to $myvar.  For quantifier `some': If for any item / iteration the satisfies clause evaluates to true, the whole quantified expression results to true. Analogously for the quantier `every'. If multiple binding expressions are given, then the results is as with multiple for clauses in a FLOWR expr; every combination of the items in the sequences is taken.

_sequence related expression_ to,union(|),intersect,except

_type-related expression_ instance of,typeswitch,cast as,castable,treat,validate

_input documents_: doc("myuri") accesses a single document. collection("myuri") accesses a collection of nodes of any kind.  How exactly the URI is associated with that collection of nodes is implementation defined.  The input document can also be specified outside the query itself.  For example a Java program could be: (new Document(File("myuri"))).evaluate("...query...").  As another example, the query processor can bind external variables, defined on the command line, to an input document. E.g. invoke the processor with "xquery -myinputdoc myinput.xml", and the query could use the variable $myinputdoc, for example like so: $myinputdoc/myelement.

_context_: In XQuery, the only operators that change the context node are the slash and the square brackets used in predicates.

_string ops_: concatenation: || or concat(...). substr("foo", 2, 3). string-length("foo"). string-join(str_list, separator_str).

_document order_: The order of nodes in an XML document or document fragment. A preorder traversal of the node tree.

misc:

- _dynamic paths_ patterns (dynamic meaning that the path expression depends on variables): find all elements with certain name and certain value doc("...")//*[name()=$name][.=$value].

- data(...) (built-in function) returns content of argument. As always, the argument is w.r.t. to the context node.

- xml document / xml element: can be used as as primary and represents itself.

 * {...} to embed an expression within a literal element: <a>{2+3}</a>

- atomization: If a value is expected, but the node is an element, it is automatically atomized. E.g. "<a>42</a>+1" yields 43.

- apparently predicates can be appended to any sequence. E.g. [1 to 10](. mod 2 = 0) returns even numbers 1 to 10.

- joins can be accomplished simply by nested for clauses in a FLOWR expression. for $a in ..., $b in ... return <foo><a>{$a}</a><b>{$b}</b></foo>


=== "Flow control"


__if (expr) then expr else expr__. The else clause is required; however as its body, you can as use the empty sequence (). The test expression is interpreted as an xs:boolean value by calculating its effective Boolean value.

__switch (expr) (case expr return expr)* default return expr__

__try { expr } catch ... { expr }__


[[flowr]]
=== FLOWR

_for clause_ for $myvar [at $myvar2] in expr: Multiple for clauses are similar to nested loops in programming languages. An alternate, more concise, syntax for multiple clauses is for ($myvar [at $myvar2] in expr ",")+.

_let clause_ let ($myvar := expr ",")+. Binds the value of expr to $myvar.

_where clause_ where expr: Filters the tuple stream, letting through tuples for which the given expr evaluates to true.

_order by clause_ [stable] order by (expr [ordermodifier] ",")+.  Sorting is by whatever the expr returns.  So expr must return a single item.  Untyped values are treated as strings. Order modifiers are `ascending' and `descending'. `empty greatest' and `empty last' specify the order of the empty sequence and NaN.  Using `stable' as first word makes the sort stable, i.e. items with the same value (w.r.t. sorting) remain in the same order.

_return clause_ return expr: Returns a sequence by evaluating expr for each tuple in the tuple stream.

The semantics of FLOWR expressions are based on tuple streams. A _tuple stream_ is an ordered sequence of one or more tuples. A _tuple_ is a set of zero or more bindings.  A tuple stream is homogeneous in the sense that all its tuples contain variables with the same names and the same static types. For example:

--------------------------------------------------
for $x in 1 to 5
                               ($x=1),  ($x=2),  ($x=3),  ($x=4),  ($x=5)
where $x >= 3
                               ($x=3),  ($x=4),  ($x=5)
--------------------------------------------------

--------------------------------------------------
for $x in 1 to 5
                               ($x=1),  ($x=2),  ($x=3),  ($x=4),  ($x=5)
group by $y := $x mod 2
                               ($x=(2,4), $y=0),  ($x=(1,3,5), $y=1)
--------------------------------------------------

So an expression (i.e. an expression tree), is behind the scenes converted to an iterator tree, where edges are tuple streams or sequences (of items) and nodes some iterator. _Materialize_ means that we compute all elements of a tuple stream or sequence. However that requires that all the elements fit into memory. In _streamed execution_ we apply the iterator principle. In _parallel execution_, the stream or the sequence is split and processed in parallel.

References:

- https://www.w3.org/TR/xquery-30/#id-flwor-expressions
